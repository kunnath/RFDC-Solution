pipeline {
    /* run on any node â€“ if you are using the Kubernetes/ Docker 
       plugin you can replace this with an explicit container block */
    agent any

    options {
        // keep builds for a week
        buildDiscarder(logRotator(daysToKeepStr: '7'))
        timestamps()
    }

    parameters {
        choice(name: 'LAYER',
               choices: ['all','db','firmware','kafka','mobile','mqtt','rest','ui'],
               description: 'Which test layer to execute')
    }

    stages {
        stage('DB Tests') {
            when {
                expression { params.LAYER == 'all' || params.LAYER == 'db' }
            }
            steps {
                // --nostatusrc prevents non-zero exit on test failures; publisher will handle build result
                sh 'robot --nostatusrc --outputdir reports/db tests/db_test.robot'
            }
        }

        stage('Firmware Tests') {
            when {
                expression { params.LAYER == 'all' || params.LAYER == 'firmware' }
            }
            steps {
                sh 'robot --nostatusrc --outputdir reports/firmware tests/firmware_test.robot'
            }
        }

        stage('Kafka Tests') {
            when {
                expression { params.LAYER == 'all' || params.LAYER == 'kafka' }
            }
            steps {
                sh 'robot --nostatusrc --outputdir reports/kafka tests/kafka_test.robot'
            }
        }

        stage('Mobile Tests') {
            when {
                expression { params.LAYER == 'all' || params.LAYER == 'mobile' }
            }
            steps {
                sh 'robot --nostatusrc --outputdir reports/mobile tests/mobile_test.robot'
            }
        }

        stage('MQTT Tests') {
            when {
                expression { params.LAYER == 'all' || params.LAYER == 'mqtt' }
            }
            steps {
                sh 'robot --nostatusrc --outputdir reports/mqtt tests/mqtt_test.robot'
            }
        }

        stage('REST Tests') {
            when {
                expression { params.LAYER == 'all' || params.LAYER == 'rest' }
            }
            steps {
                sh 'robot --nostatusrc --outputdir reports/rest tests/rest_test.robot'
            }
        }

        stage('UI Tests') {
            when {
                expression { params.LAYER == 'all' || params.LAYER == 'ui' }
            }
            steps {
                sh 'robot --nostatusrc --outputdir reports/ui tests/ui_test.robot'
            }
        }
    }

    post {
        always {
            // publish Robot Framework results using the Jenkins Robot plugin
            // use wildcards so files nested in layer subfolders are located
            // and apply thresholds similar to the provided example
            robot outputPath: 'reports',
                  outputFileName: '**/output.xml',
                  logFileName: '**/log.html',
                  reportFileName: '**/report.html',
                  passThreshold: 90.0,
                  unstableThreshold: 70.0,
                  disableArchiveOutput: true,
                  countSkippedTests: true,
                  otherFiles: 'screenshot-*.png'

            archiveArtifacts artifacts: 'reports/**/log.html, reports/**/output.xml, reports/**/report.html', fingerprint: true
            // junit step removed: Robot Framework output.xml is not JUnit format and was causing build failures
            // Jenkins Robot plugin already publishes results, no need for junit parser
        }
    }
}
